\latexhtml{}{
\HCode{
<table border="1">
<tr>
<td>Option </td>
<td> type </td>
<td> B-BB</td>
<td> B-OA</td>
<td> B-QG</td>
<td> B-Hyb</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Algorithm_choice">Algorithm choice</a> </th>
</tr>
<tr>
<td> <a href="#sec:algorithm">algorithm</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Branch-and-bound_options">Branch-and-bound options</a> </th>
</tr>
<tr>
<td> <a href="#sec:allowable_fraction_gap">allowable_fraction_gap</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:allowable_gap">allowable_gap</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:cutoff">cutoff</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:cutoff_decr">cutoff_decr</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:enable_dynamic_nlp">enable_dynamic_nlp</a> </td>
<td>S</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:integer_tolerance">integer_tolerance</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:iteration_limit">iteration_limit</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:nlp_failure_behavior">nlp_failure_behavior</a> </td>
<td>S</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:node_comparison">node_comparison</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:node_limit">node_limit</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:num_cut_passes">num_cut_passes</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:num_cut_passes_at_root">num_cut_passes_at_root</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:number_before_trust">number_before_trust</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:number_strong_branch">number_strong_branch</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:read_solution_file">read_solution_file</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:solution_limit">solution_limit</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:sos_constraints">sos_constraints</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:time_limit">time_limit</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:tree_search_strategy">tree_search_strategy</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:variable_selection">variable_selection</a> </td>
<td>S</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:MILP_cutting_planes_in_hybrid">MILP cutting planes in hybrid</a> </th>
</tr>
<tr>
<td> <a href="#sec:2mir_cuts">2mir_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:Gomory_cuts">Gomory_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:clique_cuts">clique_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:cover_cuts">cover_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:flow_cover_cuts">flow_cover_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:lift_and_project_cuts">lift_and_project_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:mir_cuts">mir_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:reduce_and_split_cuts">reduce_and_split_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:MINLP_Heuristics">MINLP Heuristics</a> </th>
</tr>
<tr>
<td> <a href="#sec:feasibility_pump_objective_norm">feasibility_pump_objective_norm</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:heuristic_RINS">heuristic_RINS</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:heuristic_dive_MIP_fractional">heuristic_dive_MIP_fractional</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:heuristic_dive_MIP_vectorLength">heuristic_dive_MIP_vectorLength</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:heuristic_dive_fractional">heuristic_dive_fractional</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:heuristic_dive_vectorLength">heuristic_dive_vectorLength</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:heuristic_feasibility_pump">heuristic_feasibility_pump</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:pump_for_minlp">pump_for_minlp</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Nlp_solution_robustness">Nlp solution robustness</a> </th>
</tr>
<tr>
<td> <a href="#sec:max_consecutive_failures">max_consecutive_failures</a> </td>
<td>I</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:max_random_point_radius">max_random_point_radius</a> </td>
<td>F</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:num_iterations_suspect">num_iterations_suspect</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:num_retry_unsolved_random_point">num_retry_unsolved_random_point</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:random_point_perturbation_interval">random_point_perturbation_interval</a> </td>
<td>F</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:random_point_type">random_point_type</a> </td>
<td>S</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:resolve_on_small_infeasibility">resolve_on_small_infeasibility</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Nlp_solve_options_in_B-Hyb">Nlp solve options in B-Hyb</a> </th>
</tr>
<tr>
<td> <a href="#sec:nlp_solve_frequency">nlp_solve_frequency</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:nlp_solve_max_depth">nlp_solve_max_depth</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:nlp_solves_per_depth">nlp_solves_per_depth</a> </td>
<td>F</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Options_for_MILP_solver">Options for MILP solver</a> </th>
</tr>
<tr>
<td> <a href="#sec:cpx_parallel_strategy">cpx_parallel_strategy</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:milp_log_level">milp_log_level</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:milp_solver">milp_solver</a> </td>
<td>S</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:milp_strategy">milp_strategy</a> </td>
<td>S</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:number_cpx_threads">number_cpx_threads</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Options_for_OA_decomposition">Options for OA decomposition</a> </th>
</tr>
<tr>
<td> <a href="#sec:oa_decomposition">oa_decomposition</a> </td>
<td>S</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:oa_log_frequency">oa_log_frequency</a> </td>
<td>F</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:oa_log_level">oa_log_level</a> </td>
<td>I</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Options_for_ecp_cuts_generation">Options for ecp cuts generation</a> </th>
</tr>
<tr>
<td> <a href="#sec:ecp_abs_tol">ecp_abs_tol</a> </td>
<td>F</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:ecp_max_rounds">ecp_max_rounds</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:ecp_probability_factor">ecp_probability_factor</a> </td>
<td>F</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:ecp_rel_tol">ecp_rel_tol</a> </td>
<td>F</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:filmint_ecp_cuts">filmint_ecp_cuts</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Options_for_feasibility_checker_using_OA_cuts">Options for feasibility checker using OA cuts</a> </th>
</tr>
<tr>
<td> <a href="#sec:feas_check_cut_types">feas_check_cut_types</a> </td>
<td>S</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:feas_check_discard_policy">feas_check_discard_policy</a> </td>
<td>S</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:generate_benders_after_so_many_oa">generate_benders_after_so_many_oa</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Options_for_feasibility_pump">Options for feasibility pump</a> </th>
</tr>
<tr>
<td> <a href="#sec:fp_log_frequency">fp_log_frequency</a> </td>
<td>F</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:fp_log_level">fp_log_level</a> </td>
<td>I</td>
<td> -</td>
<td>-</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:fp_pass_infeasible">fp_pass_infeasible</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Options_for_non-convex_problems">Options for non-convex problems</a> </th>
</tr>
<tr>
<td> <a href="#sec:coeff_var_threshold">coeff_var_threshold</a> </td>
<td>F</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:dynamic_def_cutoff_decr">dynamic_def_cutoff_decr</a> </td>
<td>S</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:first_perc_for_cutoff_decr">first_perc_for_cutoff_decr</a> </td>
<td>F</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:max_consecutive_infeasible">max_consecutive_infeasible</a> </td>
<td>I</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:num_resolve_at_infeasibles">num_resolve_at_infeasibles</a> </td>
<td>I</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:num_resolve_at_node">num_resolve_at_node</a> </td>
<td>I</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:num_resolve_at_root">num_resolve_at_root</a> </td>
<td>I</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td> <a href="#sec:second_perc_for_cutoff_decr">second_perc_for_cutoff_decr</a> </td>
<td>F</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Outer_Approximation_cuts_generation">Outer Approximation cuts generation</a> </th>
</tr>
<tr>
<td> <a href="#sec:add_only_violated_oa">add_only_violated_oa</a> </td>
<td>S</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:oa_cuts_log_level">oa_cuts_log_level</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:oa_cuts_scope">oa_cuts_scope</a> </td>
<td>S</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:tiny_element">tiny_element</a> </td>
<td>F</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:very_tiny_element">very_tiny_element</a> </td>
<td>F</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Output_and_log-level_options">Output and log-level options</a> </th>
</tr>
<tr>
<td> <a href="#sec:bb_log_interval">bb_log_interval</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:bb_log_level">bb_log_level</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:lp_log_level">lp_log_level</a> </td>
<td>I</td>
<td> -</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:nlp_log_at_root">nlp_log_at_root</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:Strong_branching_setup">Strong branching setup</a> </th>
</tr>
<tr>
<td> <a href="#sec:candidate_sort_criterion">candidate_sort_criterion</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:maxmin_crit_have_sol">maxmin_crit_have_sol</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:maxmin_crit_no_sol">maxmin_crit_no_sol</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:min_number_strong_branch">min_number_strong_branch</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:number_before_trust_list">number_before_trust_list</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:number_look_ahead">number_look_ahead</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:number_strong_branch_root">number_strong_branch_root</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:setup_pseudo_frac">setup_pseudo_frac</a> </td>
<td>F</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:trust_strong_branching_for_pseudo_cost">trust_strong_branching_for_pseudo_cost</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>   <th colspan=9> <a href="#sec:nlp_interface_option">nlp interface option</a> </th>
</tr>
<tr>
<td> <a href="#sec:file_solution">file_solution</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:nlp_log_level">nlp_log_level</a> </td>
<td>I</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:nlp_solver">nlp_solver</a> </td>
<td>S</td>
<td> +</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td> <a href="#sec:warm_start">warm_start</a> </td>
<td>S</td>
<td> +</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tr>
</table>
}
}
\subsection{Algorithm choice}
\label{sec:Algorithm_choice}
\htmlanchor{sec:Algorithm_choice}
\htmlanchor{sec:algorithm}
\paragraph{\bf algorithm:}\label{sec:algorithm} Choice of the algorithm. $\;$ \\
 This will preset some of the options of bonmin
depending on the algorithm choice.
The default value for this string option is "B-BB".
\\ 
Possible values:
\begin{itemize}
   \item B-BB: simple branch-and-bound algorithm,
   \item B-OA: OA Decomposition algorithm,
   \item B-QG: Quesada and Grossmann branch-and-cut algorithm,
   \item B-Hyb: hybrid outer approximation based branch-and-cut,
   \item B-Ecp: ecp cuts based branch-and-cut a la FilMINT.
   \item B-iFP: Iterated Feasibility Pump for MINLP.
\end{itemize}

\subsection{Branch-and-bound options}
\label{sec:Branch-and-bound_options}
\htmlanchor{sec:Branch-and-bound_options}
\htmlanchor{sec:allowable_fraction_gap}
\paragraph{\bf allowable\_fraction\_gap:}\label{sec:allowable_fraction_gap} Specify the value of relative gap under which the algorithm stops. $\;$ \\
 Stop the tree search when the gap between the
objective value of the best known solution and
the best bound on the objective of any solution
is less than this fraction of the absolute value
of the best known solution value. The valid range for this real option is 
$-1 \cdot 10^{+20} \le {\tt allowable\_fraction\_gap } \le 1 \cdot 10^{+20}$
and its default value is $0$.


\htmlanchor{sec:allowable_gap}
\paragraph{\bf allowable\_gap:}\label{sec:allowable_gap} Specify the value of absolute gap under which the algorithm stops. $\;$ \\
 Stop the tree search when the gap between the
objective value of the best known solution and
the best bound on the objective of any solution
is less than this. The valid range for this real option is 
$-1 \cdot 10^{+20} \le {\tt allowable\_gap } \le 1 \cdot 10^{+20}$
and its default value is $0$.


\htmlanchor{sec:cutoff}
\paragraph{\bf cutoff:}\label{sec:cutoff} Specify cutoff value. $\;$ \\
 cutoff should be the value of a feasible solution
known by the user (if any). The algorithm will
only look for solutions better than cutoff. The valid range for this real option is 
$-1 \cdot 10^{+100} \le {\tt cutoff } \le 1 \cdot 10^{+100}$
and its default value is $1 \cdot 10^{+100}$.


\htmlanchor{sec:cutoff_decr}
\paragraph{\bf cutoff\_decr:}\label{sec:cutoff_decr} Specify cutoff decrement. $\;$ \\
 Specify the amount by which cutoff is decremented
below a new best upper-bound (usually a small
positive value but in non-convex problems it may
be a negative value). The valid range for this real option is 
$-1 \cdot 10^{+10} \le {\tt cutoff\_decr } \le 1 \cdot 10^{+10}$
and its default value is $1 \cdot 10^{-05}$.


\htmlanchor{sec:enable_dynamic_nlp}
\paragraph{\bf enable\_dynamic\_nlp:}\label{sec:enable_dynamic_nlp} Enable dynamic linear and quadratic rows addition in nlp $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: 
   \item yes: 
\end{itemize}

\htmlanchor{sec:integer_tolerance}
\paragraph{\bf integer\_tolerance:}\label{sec:integer_tolerance} Set integer tolerance. $\;$ \\
 Any number within that value of an integer is
considered integer. The valid range for this real option is 
$0 <  {\tt integer\_tolerance } <  {\tt +inf}$
and its default value is $1 \cdot 10^{-06}$.


\htmlanchor{sec:iteration_limit}
\paragraph{\bf iteration\_limit:}\label{sec:iteration_limit} Set the cumulated maximum number of iteration in the algorithm used to process nodes continuous relaxations in the branch-and-bound. $\;$ \\
 value 0 deactivates option. The valid range for this integer option is
$0 \le {\tt iteration\_limit } <  {\tt +inf}$
and its default value is $2147483647$.


\htmlanchor{sec:nlp_failure_behavior}
\paragraph{\bf nlp\_failure\_behavior:}\label{sec:nlp_failure_behavior} Set the behavior when an NLP or a series of NLP are unsolved by Ipopt (we call unsolved an NLP for which Ipopt is not able to guarantee optimality within the specified tolerances). $\;$ \\
 If set to "fathom", the algorithm will fathom the
node when Ipopt fails to find a solution to the
nlp at that node whithin the specified
tolerances. The algorithm then becomes a
heuristic, and the user will be warned that the
solution might not be optimal.
The default value for this string option is "stop".
\\ 
Possible values:
\begin{itemize}
   \item stop: Stop when failure happens.
   \item fathom: Continue when failure happens.
\end{itemize}

\htmlanchor{sec:node_comparison}
\paragraph{\bf node\_comparison:}\label{sec:node_comparison} Choose the node selection strategy. $\;$ \\
 Choose the strategy for selecting the next node
to be processed.
The default value for this string option is "best-bound".
\\ 
Possible values:
\begin{itemize}
   \item best-bound: choose node with the smallest bound,
   \item depth-first: Perform depth first search,
   \item breadth-first: Perform breadth first search,
   \item dynamic: Cbc dynamic strategy (starts with a depth first
search and turn to best bound after 3 integer
feasible solutions have been found).
   \item best-guess: choose node with smallest guessed integer
solution
\end{itemize}

\htmlanchor{sec:node_limit}
\paragraph{\bf node\_limit:}\label{sec:node_limit} Set the maximum number of nodes explored in the branch-and-bound search. $\;$ \\
 The valid range for this integer option is
$0 \le {\tt node\_limit } <  {\tt +inf}$
and its default value is $2147483647$.


\htmlanchor{sec:num_cut_passes}
\paragraph{\bf num\_cut\_passes:}\label{sec:num_cut_passes} Set the maximum number of cut passes at regular nodes of the branch-and-cut. $\;$ \\
 The valid range for this integer option is
$0 \le {\tt num\_cut\_passes } <  {\tt +inf}$
and its default value is $1$.


\htmlanchor{sec:num_cut_passes_at_root}
\paragraph{\bf num\_cut\_passes\_at\_root:}\label{sec:num_cut_passes_at_root} Set the maximum number of cut passes at regular nodes of the branch-and-cut. $\;$ \\
 The valid range for this integer option is
$0 \le {\tt num\_cut\_passes\_at\_root } <  {\tt +inf}$
and its default value is $20$.


\htmlanchor{sec:number_before_trust}
\paragraph{\bf number\_before\_trust:}\label{sec:number_before_trust} Set the number of branches on a variable before its pseudo costs are to be believed in dynamic strong branching. $\;$ \\
 A value of 0 disables pseudo costs. The valid range for this integer option is
$0 \le {\tt number\_before\_trust } <  {\tt +inf}$
and its default value is $8$.


\htmlanchor{sec:number_strong_branch}
\paragraph{\bf number\_strong\_branch:}\label{sec:number_strong_branch} Choose the maximum number of variables considered for strong branching. $\;$ \\
 Set the number of variables on which to do strong
branching. The valid range for this integer option is
$0 \le {\tt number\_strong\_branch } <  {\tt +inf}$
and its default value is $20$.


\htmlanchor{sec:read_solution_file}
\paragraph{\bf read\_solution\_file:}\label{sec:read_solution_file} Read a file with the optimal solution to test if algorithms cuts it. $\;$ \\
 For Debugging purposes only.
The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: 
   \item yes: 
\end{itemize}

\htmlanchor{sec:solution_limit}
\paragraph{\bf solution\_limit:}\label{sec:solution_limit} Abort after that much integer feasible solution have been found by algorithm $\;$ \\
 value 0 deactivates option The valid range for this integer option is
$0 \le {\tt solution\_limit } <  {\tt +inf}$
and its default value is $2147483647$.


\htmlanchor{sec:sos_constraints}
\paragraph{\bf sos\_constraints:}\label{sec:sos_constraints} Wether or not to activate SOS constraints. $\;$ \\
 (only type 1 SOS are supported at the moment)
The default value for this string option is "enable".
\\ 
Possible values:
\begin{itemize}
   \item enable: 
   \item disable: 
\end{itemize}

\htmlanchor{sec:time_limit}
\paragraph{\bf time\_limit:}\label{sec:time_limit} Set the global maximum computation time (in secs) for the algorithm. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt time\_limit } <  {\tt +inf}$
and its default value is $1 \cdot 10^{+10}$.


\htmlanchor{sec:tree_search_strategy}
\paragraph{\bf tree\_search\_strategy:}\label{sec:tree_search_strategy} Pick a strategy for traversing the tree $\;$ \\
 All strategies can be used in conjunction with
any of the node comparison functions. Options
which affect dfs-dive are max-backtracks-in-dive
and max-dive-depth. The dfs-dive won't work in a
non-convex problem where objective does not
decrease down branches.
The default value for this string option is "probed-dive".
\\ 
Possible values:
\begin{itemize}
   \item top-node:  Always pick the top node as sorted by the node
comparison function
   \item dive: Dive in the tree if possible, otherwise pick
top node as sorted by the tree comparison
function.
   \item probed-dive: Dive in the tree exploring two childs before
continuing the dive at each level.
   \item dfs-dive: Dive in the tree if possible doing a depth
first search. Backtrack on leaves or when a
prescribed depth is attained or when estimate
of best possible integer feasible solution in
subtree is worst than cutoff. Once a prescribed
limit of backtracks is attained pick top node
as sorted by the tree comparison function
   \item dfs-dive-dynamic: Same as dfs-dive but once enough solution are
found switch to best-bound and if too many
nodes switch to depth-first.
\end{itemize}

\htmlanchor{sec:variable_selection}
\paragraph{\bf variable\_selection:}\label{sec:variable_selection} Chooses variable selection strategy $\;$ \\

The default value for this string option is "strong-branching".
\\ 
Possible values:
\begin{itemize}
   \item most-fractional: Choose most fractional variable
   \item strong-branching: Perform strong branching
   \item reliability-branching: Use reliability branching
   \item qp-strong-branching: Perform strong branching with QP approximation
   \item lp-strong-branching: Perform strong branching with LP approximation
   \item nlp-strong-branching: Perform strong branching with NLP approximation
   \item osi-simple: Osi method to do simple branching
   \item osi-strong: Osi method to do strong branching
   \item random: Method to choose branching variable randomly
\end{itemize}

\subsection{MILP cutting planes in hybrid}
\label{sec:MILP_cutting_planes_in_hybrid}
\htmlanchor{sec:MILP_cutting_planes_in_hybrid}
\htmlanchor{sec:2mir_cuts}
\paragraph{\bf 2mir\_cuts:}\label{sec:2mir_cuts} Frequency (in terms of nodes) for generating 2-MIR cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt 2mir\_cuts } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:Gomory_cuts}
\paragraph{\bf Gomory\_cuts:}\label{sec:Gomory_cuts} Frequency k (in terms of nodes) for generating Gomory cuts in branch-and-cut. $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt Gomory\_cuts } <  {\tt +inf}$
and its default value is $-5$.


\htmlanchor{sec:clique_cuts}
\paragraph{\bf clique\_cuts:}\label{sec:clique_cuts} Frequency (in terms of nodes) for generating clique cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt clique\_cuts } <  {\tt +inf}$
and its default value is $-5$.


\htmlanchor{sec:cover_cuts}
\paragraph{\bf cover\_cuts:}\label{sec:cover_cuts} Frequency (in terms of nodes) for generating cover cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt cover\_cuts } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:flow_cover_cuts}
\paragraph{\bf flow\_cover\_cuts:}\label{sec:flow_cover_cuts} Frequency (in terms of nodes) for generating flow cover cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt flow\_cover\_cuts } <  {\tt +inf}$
and its default value is $-5$.


\htmlanchor{sec:lift_and_project_cuts}
\paragraph{\bf lift\_and\_project\_cuts:}\label{sec:lift_and_project_cuts} Frequency (in terms of nodes) for generating lift-and-project cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt lift\_and\_project\_cuts } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:mir_cuts}
\paragraph{\bf mir\_cuts:}\label{sec:mir_cuts} Frequency (in terms of nodes) for generating MIR cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt mir\_cuts } <  {\tt +inf}$
and its default value is $-5$.


\htmlanchor{sec:reduce_and_split_cuts}
\paragraph{\bf reduce\_and\_split\_cuts:}\label{sec:reduce_and_split_cuts} Frequency (in terms of nodes) for generating reduce-and-split cuts in branch-and-cut $\;$ \\
 If $k > 0$, cuts are generated every k nodes, if
$-99 < k < 0$ cuts are generated every $-k$ nodes
but Cbc may decide to stop generating cuts, if
not enough are generated at the root node, if
$k=-99$ generate cuts only at the root node, if
$k=0$ or $100$ do not generate cuts. The valid range for this integer option is
$-100 \le {\tt reduce\_and\_split\_cuts } <  {\tt +inf}$
and its default value is $0$.


\subsection{MINLP Heuristics}
\label{sec:MINLP_Heuristics}
\htmlanchor{sec:MINLP_Heuristics}
\htmlanchor{sec:feasibility_pump_objective_norm}
\paragraph{\bf feasibility\_pump\_objective\_norm:}\label{sec:feasibility_pump_objective_norm} Norm of feasibility pump objective function $\;$ \\
 The valid range for this integer option is
$1 \le {\tt feasibility\_pump\_objective\_norm } \le 2$
and its default value is $1$.


\htmlanchor{sec:heuristic_RINS}
\paragraph{\bf heuristic\_RINS:}\label{sec:heuristic_RINS} if yes runs the RINS heuristic $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't run it
   \item yes: runs the heuristic
\end{itemize}

\htmlanchor{sec:heuristic_dive_MIP_fractional}
\paragraph{\bf heuristic\_dive\_MIP\_fractional:}\label{sec:heuristic_dive_MIP_fractional} if yes runs the Dive MIP Fractional heuristic $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't run it
   \item yes: runs the heuristic
\end{itemize}

\htmlanchor{sec:heuristic_dive_MIP_vectorLength}
\paragraph{\bf heuristic\_dive\_MIP\_vectorLength:}\label{sec:heuristic_dive_MIP_vectorLength} if yes runs the Dive MIP VectorLength heuristic $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't run it
   \item yes: runs the heuristic
\end{itemize}

\htmlanchor{sec:heuristic_dive_fractional}
\paragraph{\bf heuristic\_dive\_fractional:}\label{sec:heuristic_dive_fractional} if yes runs the Dive Fractional heuristic $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't run it
   \item yes: runs the heuristic
\end{itemize}

\htmlanchor{sec:heuristic_dive_vectorLength}
\paragraph{\bf heuristic\_dive\_vectorLength:}\label{sec:heuristic_dive_vectorLength} if yes runs the Dive VectorLength heuristic $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't run it
   \item yes: runs the heuristic
\end{itemize}

\htmlanchor{sec:heuristic_feasibility_pump}
\paragraph{\bf heuristic\_feasibility\_pump:}\label{sec:heuristic_feasibility_pump} whether the heuristic feasibility pump should be used $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't use it
   \item yes: use it
\end{itemize}

\htmlanchor{sec:pump_for_minlp}
\paragraph{\bf pump\_for\_minlp:}\label{sec:pump_for_minlp} if yes runs FP for MINLP $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: don't run it
   \item yes: runs the heuristic
\end{itemize}

\subsection{Nlp solution robustness}
\label{sec:Nlp_solution_robustness}
\htmlanchor{sec:Nlp_solution_robustness}
\htmlanchor{sec:max_consecutive_failures}
\paragraph{\bf max\_consecutive\_failures:}\label{sec:max_consecutive_failures} (temporarily removed) Number $n$ of consecutive unsolved problems before aborting a branch of the tree. $\;$ \\
 When $n > 0$, continue exploring a branch of the
tree until $n$ consecutive problems in the branch
are unsolved (we call unsolved a problem for
which Ipopt can not guarantee optimality within
the specified tolerances). The valid range for this integer option is
$0 \le {\tt max\_consecutive\_failures } <  {\tt +inf}$
and its default value is $10$.


\htmlanchor{sec:max_random_point_radius}
\paragraph{\bf max\_random\_point\_radius:}\label{sec:max_random_point_radius} Set max value r for coordinate of a random point. $\;$ \\
 When picking a random point, coordinate i will be
in the interval [min(max(l,-r),u-r),
max(min(u,r),l+r)] (where l is the lower bound
for the variable and u is its upper bound) The valid range for this real option is 
$0 <  {\tt max\_random\_point\_radius } <  {\tt +inf}$
and its default value is $100000$.


\htmlanchor{sec:num_iterations_suspect}
\paragraph{\bf num\_iterations\_suspect:}\label{sec:num_iterations_suspect} Number of iterations over which a node is considered "suspect" (for debugging purposes only, see detailed documentation). $\;$ \\
 When the number of iterations to solve a node is
above this number, the subproblem at this node is
considered to be suspect and it will be outputed
in a file (set to -1 to deactivate this). The valid range for this integer option is
$-1 \le {\tt num\_iterations\_suspect } <  {\tt +inf}$
and its default value is $-1$.


\htmlanchor{sec:num_retry_unsolved_random_point}
\paragraph{\bf num\_retry\_unsolved\_random\_point:}\label{sec:num_retry_unsolved_random_point} Number $k$ of times that the algorithm will try to resolve an unsolved NLP with a random starting point (we call unsolved an NLP for which Ipopt is not able to guarantee optimality within the specified tolerances). $\;$ \\
 When Ipopt fails to solve a continuous NLP
sub-problem, if $k > 0$, the algorithm will try
again to solve the failed NLP with $k$ new
randomly chosen starting points  or until the
problem is solved with success. The valid range for this integer option is
$0 \le {\tt num\_retry\_unsolved\_random\_point } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:random_point_perturbation_interval}
\paragraph{\bf random\_point\_perturbation\_interval:}\label{sec:random_point_perturbation_interval} Amount by which starting point is perturbed when choosing to pick random point by perturbating starting point $\;$ \\
 The valid range for this real option is 
$0 <  {\tt random\_point\_perturbation\_interval } <  {\tt +inf}$
and its default value is $1$.


\htmlanchor{sec:random_point_type}
\paragraph{\bf random\_point\_type:}\label{sec:random_point_type} method to choose a random starting point $\;$ \\

The default value for this string option is "Jon".
\\ 
Possible values:
\begin{itemize}
   \item Jon: Choose random point uniformly between the bounds
   \item Andreas: perturb the starting point of the problem
within a prescribed interval
   \item Claudia: perturb the starting point using the
perturbation radius suffix information
\end{itemize}

\htmlanchor{sec:resolve_on_small_infeasibility}
\paragraph{\bf resolve\_on\_small\_infeasibility:}\label{sec:resolve_on_small_infeasibility} If a locally infeasible problem is infeasible by less than this resolve itwith initial starting point. $\;$ \\
 It is set to 0 by default with Ipopt. For filter
Bonmin sets it to a small value. The valid range for this real option is 
$0 \le {\tt resolve\_on\_small\_infeasibility } <  {\tt +inf}$
and its default value is $0$.


\subsection{Nlp solve options in B-Hyb}
\label{sec:Nlp_solve_options_in_B-Hyb}
\htmlanchor{sec:Nlp_solve_options_in_B-Hyb}
\htmlanchor{sec:nlp_solve_frequency}
\paragraph{\bf nlp\_solve\_frequency:}\label{sec:nlp_solve_frequency} Specify the frequency (in terms of nodes) at which NLP relaxations are solved in B-Hyb. $\;$ \\
 A frequency of 0 amounts to to never solve the
NLP relaxation. The valid range for this integer option is
$0 \le {\tt nlp\_solve\_frequency } <  {\tt +inf}$
and its default value is $10$.


\htmlanchor{sec:nlp_solve_max_depth}
\paragraph{\bf nlp\_solve\_max\_depth:}\label{sec:nlp_solve_max_depth} Set maximum depth in the tree at which NLP relaxations are solved in B-Hyb. $\;$ \\
 A depth of 0 amounts to to never solve the NLP
relaxation. The valid range for this integer option is
$0 \le {\tt nlp\_solve\_max\_depth } <  {\tt +inf}$
and its default value is $10$.


\htmlanchor{sec:nlp_solves_per_depth}
\paragraph{\bf nlp\_solves\_per\_depth:}\label{sec:nlp_solves_per_depth} Set average number of nodes in the tree at which NLP relaxations are solved in B-Hyb for each depth. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt nlp\_solves\_per\_depth } <  {\tt +inf}$
and its default value is $1 \cdot 10^{+100}$.


\subsection{Options for MILP solver}
\label{sec:Options_for_MILP_solver}
\htmlanchor{sec:Options_for_MILP_solver}
\htmlanchor{sec:cpx_parallel_strategy}
\paragraph{\bf cpx\_parallel\_strategy:}\label{sec:cpx_parallel_strategy} Strategy of parallel search mode in CPLEX. $\;$ \\
 -1 = opportunistic, 0 = automatic, 1 =
deterministic (refer to CPLEX documentation) The valid range for this integer option is
$-1 \le {\tt cpx\_parallel\_strategy } \le 1$
and its default value is $0$.


\htmlanchor{sec:milp_log_level}
\paragraph{\bf milp\_log\_level:}\label{sec:milp_log_level} specify MILP solver log level. $\;$ \\
 Set the level of output of the MILP subsolver in
OA : 0 - none, 1 - minimal, 2 - normal low, 3 -
normal high The valid range for this integer option is
$0 \le {\tt milp\_log\_level } \le 4$
and its default value is $0$.


\htmlanchor{sec:milp_solver}
\paragraph{\bf milp\_solver:}\label{sec:milp_solver} Choose the subsolver to solve MILP sub-problems in OA decompositions. $\;$ \\
  To use Cplex, a valid license is required and
you should have compiled OsiCpx in COIN-OR  (see
Osi documentation).
The default value for this string option is "Cbc\_D".
\\ 
Possible values:
\begin{itemize}
   \item Cbc\_D: Coin Branch and Cut with its default
   \item Cbc\_Par: Coin Branch and Cut with passed parameters
   \item Cplex: Ilog Cplex
\end{itemize}

\htmlanchor{sec:milp_strategy}
\paragraph{\bf milp\_strategy:}\label{sec:milp_strategy} Choose a strategy for MILPs. $\;$ \\

The default value for this string option is "find\_good\_sol".
\\ 
Possible values:
\begin{itemize}
   \item find\_good\_sol: Stop sub milps when a solution improving the
incumbent is found
   \item solve\_to\_optimality: Solve MILPs to optimality
\end{itemize}

\htmlanchor{sec:number_cpx_threads}
\paragraph{\bf number\_cpx\_threads:}\label{sec:number_cpx_threads} Set number of threads to use with cplex. $\;$ \\
 (refer to CPLEX documentation) The valid range for this integer option is
$0 \le {\tt number\_cpx\_threads } <  {\tt +inf}$
and its default value is $0$.


\subsection{Options for OA decomposition}
\label{sec:Options_for_OA_decomposition}
\htmlanchor{sec:Options_for_OA_decomposition}
\htmlanchor{sec:oa_decomposition}
\paragraph{\bf oa\_decomposition:}\label{sec:oa_decomposition} If yes do initial OA decomposition $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: 
   \item yes: 
\end{itemize}

\htmlanchor{sec:oa_log_frequency}
\paragraph{\bf oa\_log\_frequency:}\label{sec:oa_log_frequency} display an update on lower and upper bounds in OA every n seconds $\;$ \\
 The valid range for this real option is 
$0 <  {\tt oa\_log\_frequency } <  {\tt +inf}$
and its default value is $100$.


\htmlanchor{sec:oa_log_level}
\paragraph{\bf oa\_log\_level:}\label{sec:oa_log_level} specify OA iterations log level. $\;$ \\
 Set the level of output of OA decomposition
solver : 0 - none, 1 - normal, 2 - verbose The valid range for this integer option is
$0 \le {\tt oa\_log\_level } \le 2$
and its default value is $1$.


\subsection{Options for ecp cuts generation}
\label{sec:Options_for_ecp_cuts_generation}
\htmlanchor{sec:Options_for_ecp_cuts_generation}
\htmlanchor{sec:ecp_abs_tol}
\paragraph{\bf ecp\_abs\_tol:}\label{sec:ecp_abs_tol} Set the absolute termination tolerance for ECP rounds. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt ecp\_abs\_tol } <  {\tt +inf}$
and its default value is $1 \cdot 10^{-06}$.


\htmlanchor{sec:ecp_max_rounds}
\paragraph{\bf ecp\_max\_rounds:}\label{sec:ecp_max_rounds} Set the maximal number of rounds of ECP cuts. $\;$ \\
 The valid range for this integer option is
$0 \le {\tt ecp\_max\_rounds } <  {\tt +inf}$
and its default value is $5$.


\htmlanchor{sec:ecp_probability_factor}
\paragraph{\bf ecp\_probability\_factor:}\label{sec:ecp_probability_factor} Factor appearing in formula for skipping ECP cuts. $\;$ \\
 Choosing -1 disables the skipping. The valid range for this real option is 
${\tt -inf} <  {\tt ecp\_probability\_factor } <  {\tt +inf}$
and its default value is $10$.


\htmlanchor{sec:ecp_rel_tol}
\paragraph{\bf ecp\_rel\_tol:}\label{sec:ecp_rel_tol} Set the relative termination tolerance for ECP rounds. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt ecp\_rel\_tol } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:filmint_ecp_cuts}
\paragraph{\bf filmint\_ecp\_cuts:}\label{sec:filmint_ecp_cuts} Specify the frequency (in terms of nodes) at which some a la filmint ecp cuts are generated. $\;$ \\
 A frequency of 0 amounts to to never solve the
NLP relaxation. The valid range for this integer option is
$0 \le {\tt filmint\_ecp\_cuts } <  {\tt +inf}$
and its default value is $0$.


\subsection{Options for feasibility checker using OA cuts}
\label{sec:Options_for_feasibility_checker_using_OA_cuts}
\htmlanchor{sec:Options_for_feasibility_checker_using_OA_cuts}
\htmlanchor{sec:feas_check_cut_types}
\paragraph{\bf feas\_check\_cut\_types:}\label{sec:feas_check_cut_types} Choose the type of cuts generated when an integer feasible solution is found $\;$ \\
 If it seems too much memory is used should try
Benders to use less
The default value for this string option is "outer-approx".
\\ 
Possible values:
\begin{itemize}
   \item outer-approx: Generate a set of Outer Approximations cuts.
   \item Benders: Generate a single Benders cut.
\end{itemize}

\htmlanchor{sec:feas_check_discard_policy}
\paragraph{\bf feas\_check\_discard\_policy:}\label{sec:feas_check_discard_policy} How cuts from feasibility checker are discarded $\;$ \\
 Normally to avoid cycle cuts from feasibility
checker should not be discarded in the node where
they are generated. However Cbc sometimes does it
if no care is taken which can lead to an infinite
loop in Bonmin (usualy on simple problems). To
avoid this one can instruct Cbc to never discard
a cut but if we do that for all cuts it can lead
to memory problems. The default policy here is to
detect cycles and only then impose to Cbc to keep
the cut. The two other alternative are to
instruct Cbc to keep all cuts or to just ignore
the problem and hope for the best
The default value for this string option is "detect-cycles".
\\ 
Possible values:
\begin{itemize}
   \item detect-cycles: Detect if a cycle occurs and only in this case
force not to discard.
   \item keep-all: Force cuts from feasibility checker not to be
discarded (memory hungry but sometimes better).
   \item treated-as-normal: Cuts from memory checker can be discarded as
any other cuts (code may cycle then)
\end{itemize}

\htmlanchor{sec:generate_benders_after_so_many_oa}
\paragraph{\bf generate\_benders\_after\_so\_many\_oa:}\label{sec:generate_benders_after_so_many_oa} Specify that after so many oa cuts have been generated Benders cuts should be generated instead. $\;$ \\
 It seems that sometimes generating too many oa
cuts slows down the optimization compared to
Benders due to the size of the LP. With this
option we specify that after so many OA cuts have
been generated we should switch to Benders cuts. The valid range for this integer option is
$0 \le {\tt generate\_benders\_after\_so\_many\_oa } <  {\tt +inf}$
and its default value is $5000$.


\subsection{Options for feasibility pump}
\label{sec:Options_for_feasibility_pump}
\htmlanchor{sec:Options_for_feasibility_pump}
\htmlanchor{sec:fp_log_frequency}
\paragraph{\bf fp\_log\_frequency:}\label{sec:fp_log_frequency} display an update on lower and upper bounds in FP every n seconds $\;$ \\
 The valid range for this real option is 
$0 <  {\tt fp\_log\_frequency } <  {\tt +inf}$
and its default value is $100$.


\htmlanchor{sec:fp_log_level}
\paragraph{\bf fp\_log\_level:}\label{sec:fp_log_level} specify FP iterations log level. $\;$ \\
 Set the level of output of OA decomposition
solver : 0 - none, 1 - normal, 2 - verbose The valid range for this integer option is
$0 \le {\tt fp\_log\_level } \le 2$
and its default value is $1$.


\htmlanchor{sec:fp_pass_infeasible}
\paragraph{\bf fp\_pass\_infeasible:}\label{sec:fp_pass_infeasible} Say whether feasibility pump should claim to converge or not $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: When master MILP is infeasible just bail out
(don't stop all algorithm). This is the option
for using in B-Hyb.
   \item yes: Claim convergence, numerically dangerous.
\end{itemize}

\subsection{Options for non-convex problems}
\label{sec:Options_for_non-convex_problems}
\htmlanchor{sec:Options_for_non-convex_problems}
\htmlanchor{sec:coeff_var_threshold}
\paragraph{\bf coeff\_var\_threshold:}\label{sec:coeff_var_threshold} Coefficient of variation threshold (for dynamic definition of cutoff\_decr). $\;$ \\
 The valid range for this real option is 
$0 \le {\tt coeff\_var\_threshold } <  {\tt +inf}$
and its default value is $0.1$.


\htmlanchor{sec:dynamic_def_cutoff_decr}
\paragraph{\bf dynamic\_def\_cutoff\_decr:}\label{sec:dynamic_def_cutoff_decr} Do you want to define the parameter cutoff\_decr dynamically? $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: No, define it statically
   \item yes: Yes, define it dynamically
\end{itemize}

\htmlanchor{sec:first_perc_for_cutoff_decr}
\paragraph{\bf first\_perc\_for\_cutoff\_decr:}\label{sec:first_perc_for_cutoff_decr} The percentage used when, the coeff of variance is smaller than the threshold, to compute the cutoff\_decr dynamically. $\;$ \\
 The valid range for this real option is 
${\tt -inf} <  {\tt first\_perc\_for\_cutoff\_decr } <  {\tt +inf}$
and its default value is $-0.02$.


\htmlanchor{sec:max_consecutive_infeasible}
\paragraph{\bf max\_consecutive\_infeasible:}\label{sec:max_consecutive_infeasible} Number of consecutive infeasible subproblems before aborting a branch. $\;$ \\
 Will continue exploring a branch of the tree
until "max\_consecutive\_infeasible"consecutive
problems are infeasibles by the NLP sub-solver. The valid range for this integer option is
$0 \le {\tt max\_consecutive\_infeasible } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:num_resolve_at_infeasibles}
\paragraph{\bf num\_resolve\_at\_infeasibles:}\label{sec:num_resolve_at_infeasibles} Number $k$ of tries to resolve an infeasible node (other than the root) of the tree with different starting point. $\;$ \\
 The algorithm will solve all the infeasible nodes
with $k$ different random starting points and
will keep the best local optimum found. The valid range for this integer option is
$0 \le {\tt num\_resolve\_at\_infeasibles } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:num_resolve_at_node}
\paragraph{\bf num\_resolve\_at\_node:}\label{sec:num_resolve_at_node} Number $k$ of tries to resolve a node (other than the root) of the tree with different starting point. $\;$ \\
 The algorithm will solve all the nodes with $k$
different random starting points and will keep
the best local optimum found. The valid range for this integer option is
$0 \le {\tt num\_resolve\_at\_node } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:num_resolve_at_root}
\paragraph{\bf num\_resolve\_at\_root:}\label{sec:num_resolve_at_root} Number $k$ of tries to resolve the root node with different starting points. $\;$ \\
 The algorithm will solve the root node with $k$
random starting points and will keep the best
local optimum found. The valid range for this integer option is
$0 \le {\tt num\_resolve\_at\_root } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:second_perc_for_cutoff_decr}
\paragraph{\bf second\_perc\_for\_cutoff\_decr:}\label{sec:second_perc_for_cutoff_decr} The percentage used when, the coeff of variance is greater than the threshold, to compute the cutoff\_decr dynamically. $\;$ \\
 The valid range for this real option is 
${\tt -inf} <  {\tt second\_perc\_for\_cutoff\_decr } <  {\tt +inf}$
and its default value is $-0.05$.


\subsection{Outer Approximation cuts generation}
\label{sec:Outer_Approximation_cuts_generation}
\htmlanchor{sec:Outer_Approximation_cuts_generation}
\htmlanchor{sec:add_only_violated_oa}
\paragraph{\bf add\_only\_violated\_oa:}\label{sec:add_only_violated_oa} Do we add all OA cuts or only the ones violated by current point? $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item no: Add all cuts
   \item yes: Add only violated Cuts
\end{itemize}

\htmlanchor{sec:oa_cuts_log_level}
\paragraph{\bf oa\_cuts\_log\_level:}\label{sec:oa_cuts_log_level} level of log when generating OA cuts. $\;$ \\
 0: outputs nothing,
1: when a cut is generated,
its violation and index of row from which it
originates,
2: always output violation of the
cut.
3: output generated cuts incidence vectors. The valid range for this integer option is
$0 \le {\tt oa\_cuts\_log\_level } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:oa_cuts_scope}
\paragraph{\bf oa\_cuts\_scope:}\label{sec:oa_cuts_scope} Specify if OA cuts added are to be set globally or locally valid $\;$ \\

The default value for this string option is "global".
\\ 
Possible values:
\begin{itemize}
   \item local: Cuts are treated as locally valid
   \item global: Cuts are treated as globally valid
\end{itemize}

\htmlanchor{sec:tiny_element}
\paragraph{\bf tiny\_element:}\label{sec:tiny_element} Value for tiny element in OA cut $\;$ \\
 We will remove "cleanly" (by relaxing cut) an
element lower than this. The valid range for this real option is 
$-0 \le {\tt tiny\_element } <  {\tt +inf}$
and its default value is $1 \cdot 10^{-08}$.


\htmlanchor{sec:very_tiny_element}
\paragraph{\bf very\_tiny\_element:}\label{sec:very_tiny_element} Value for very tiny element in OA cut $\;$ \\
 Algorithm will take the risk of neglecting an
element lower than this. The valid range for this real option is 
$-0 \le {\tt very\_tiny\_element } <  {\tt +inf}$
and its default value is $1 \cdot 10^{-17}$.


\subsection{Output and log-level options}
\label{sec:Output_and_log-level_options}
\htmlanchor{sec:Output_and_log-level_options}
\htmlanchor{sec:bb_log_interval}
\paragraph{\bf bb\_log\_interval:}\label{sec:bb_log_interval} Interval at which node level output is printed. $\;$ \\
 Set the interval (in terms of number of nodes) at
which a log on node resolutions (consisting of
lower and upper bounds) is given. The valid range for this integer option is
$0 \le {\tt bb\_log\_interval } <  {\tt +inf}$
and its default value is $100$.


\htmlanchor{sec:bb_log_level}
\paragraph{\bf bb\_log\_level:}\label{sec:bb_log_level} specify main branch-and-bound log level. $\;$ \\
 Set the level of output of the branch-and-bound :
0 - none, 1 - minimal, 2 - normal low, 3 - normal
high The valid range for this integer option is
$0 \le {\tt bb\_log\_level } \le 5$
and its default value is $1$.


\htmlanchor{sec:lp_log_level}
\paragraph{\bf lp\_log\_level:}\label{sec:lp_log_level} specify LP log level. $\;$ \\
 Set the level of output of the linear programming
sub-solver in B-Hyb or B-QG : 0 - none, 1 -
minimal, 2 - normal low, 3 - normal high, 4 -
verbose The valid range for this integer option is
$0 \le {\tt lp\_log\_level } \le 4$
and its default value is $0$.


\htmlanchor{sec:nlp_log_at_root}
\paragraph{\bf nlp\_log\_at\_root:}\label{sec:nlp_log_at_root}  Specify a different log level for root relaxtion. $\;$ \\
 The valid range for this integer option is
$0 \le {\tt nlp\_log\_at\_root } \le 12$
and its default value is $0$.


\subsection{Strong branching setup}
\label{sec:Strong_branching_setup}
\htmlanchor{sec:Strong_branching_setup}
\htmlanchor{sec:candidate_sort_criterion}
\paragraph{\bf candidate\_sort\_criterion:}\label{sec:candidate_sort_criterion} Choice of the criterion to choose candidates in strong-branching $\;$ \\

The default value for this string option is "best-ps-cost".
\\ 
Possible values:
\begin{itemize}
   \item best-ps-cost: Sort by decreasing pseudo-cost
   \item worst-ps-cost: Sort by increasing pseudo-cost
   \item most-fractional: Sort by decreasing integer infeasibility
   \item least-fractional: Sort by increasing integer infeasibility
\end{itemize}

\htmlanchor{sec:maxmin_crit_have_sol}
\paragraph{\bf maxmin\_crit\_have\_sol:}\label{sec:maxmin_crit_have_sol} Weight towards minimum in of lower and upper branching estimates when a solution has been found. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt maxmin\_crit\_have\_sol } \le 1$
and its default value is $0.1$.


\htmlanchor{sec:maxmin_crit_no_sol}
\paragraph{\bf maxmin\_crit\_no\_sol:}\label{sec:maxmin_crit_no_sol} Weight towards minimum in of lower and upper branching estimates when no solution has been found yet. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt maxmin\_crit\_no\_sol } \le 1$
and its default value is $0.7$.


\htmlanchor{sec:min_number_strong_branch}
\paragraph{\bf min\_number\_strong\_branch:}\label{sec:min_number_strong_branch} Sets minimum number of variables for strong branching (overriding trust) $\;$ \\
 The valid range for this integer option is
$0 \le {\tt min\_number\_strong\_branch } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:number_before_trust_list}
\paragraph{\bf number\_before\_trust\_list:}\label{sec:number_before_trust_list} Set the number of branches on a variable before its pseudo costs are to be believed during setup of strong branching candidate list. $\;$ \\
 The default value is that of
"number\_before\_trust" The valid range for this integer option is
$-1 \le {\tt number\_before\_trust\_list } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:number_look_ahead}
\paragraph{\bf number\_look\_ahead:}\label{sec:number_look_ahead} Sets limit of look-ahead strong-branching trials $\;$ \\
 The valid range for this integer option is
$0 \le {\tt number\_look\_ahead } <  {\tt +inf}$
and its default value is $0$.


\htmlanchor{sec:number_strong_branch_root}
\paragraph{\bf number\_strong\_branch\_root:}\label{sec:number_strong_branch_root} Maximum number of variables considered for strong branching in root node. $\;$ \\
 The valid range for this integer option is
$0 \le {\tt number\_strong\_branch\_root } <  {\tt +inf}$
and its default value is $2147483647$.


\htmlanchor{sec:setup_pseudo_frac}
\paragraph{\bf setup\_pseudo\_frac:}\label{sec:setup_pseudo_frac} Proportion of strong branching list that has to be taken from most-integer-infeasible list. $\;$ \\
 The valid range for this real option is 
$0 \le {\tt setup\_pseudo\_frac } \le 1$
and its default value is $0.5$.


\htmlanchor{sec:trust_strong_branching_for_pseudo_cost}
\paragraph{\bf trust\_strong\_branching\_for\_pseudo\_cost:}\label{sec:trust_strong_branching_for_pseudo_cost} Whether or not to trust strong branching results for updating pseudo costs. $\;$ \\

The default value for this string option is "yes".
\\ 
Possible values:
\begin{itemize}
   \item no: 
   \item yes: 
\end{itemize}

\subsection{nlp interface option}
\label{sec:nlp_interface_option}
\htmlanchor{sec:nlp_interface_option}
\htmlanchor{sec:file_solution}
\paragraph{\bf file\_solution:}\label{sec:file_solution} Write a file bonmin.sol with the solution $\;$ \\

The default value for this string option is "no".
\\ 
Possible values:
\begin{itemize}
   \item yes: 
   \item no: 
\end{itemize}

\htmlanchor{sec:nlp_log_level}
\paragraph{\bf nlp\_log\_level:}\label{sec:nlp_log_level} specify NLP solver interface log level (independent from ipopt print\_level). $\;$ \\
 Set the level of output of the OsiTMINLPInterface
: 0 - none, 1 - normal, 2 - verbose The valid range for this integer option is
$0 \le {\tt nlp\_log\_level } \le 2$
and its default value is $1$.


\htmlanchor{sec:nlp_solver}
\paragraph{\bf nlp\_solver:}\label{sec:nlp_solver} Choice of the solver for local optima of continuous nlp's $\;$ \\
 Note that option will work only if the specified
solver has been installed. Ipopt will usualy be
installed with Bonmin by default. For FilterSQP
please see
http://www-unix.mcs.anl.gov/~leyffer/solvers.html
on how to obtain it and
https://projects.coin-or.org/Bonmin/wiki/HintTric-
ks on how to configure Bonmin to use it.
The default value for this string option is "Ipopt".
\\ 
Possible values:
\begin{itemize}
   \item Ipopt: Interior Point OPTimizer
(https://projects.coin-or.org/Ipopt)
   \item filterSQP: Sequential quadratic programming trust region
algorithm
(http://www-unix.mcs.anl.gov/~leyffer/solvers.h-
tml)
   \item all: run all available solvers at each node
\end{itemize}

\htmlanchor{sec:warm_start}
\paragraph{\bf warm\_start:}\label{sec:warm_start} Select the warm start method $\;$ \\
 This will affect the function getWarmStart(), and
as a consequence the warm starting in the various
algorithms.
The default value for this string option is "none".
\\ 
Possible values:
\begin{itemize}
   \item none: No warm start just start NLPs from optimal
solution of the root relaxation
   \item fake\_basis: builds fake bases usefull for cut management in
Cbc (warm start is the same as in none)
   \item optimum: Warm start with direct parent optimum
   \item interior\_point: Warm start with an interior point of direct
parent
\end{itemize}

